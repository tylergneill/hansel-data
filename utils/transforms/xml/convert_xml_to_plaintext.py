import argparse
from lxml import etree
from pathlib import Path
import re

CHAR_FOR_PENDING_HEAD = "_"

class XMLToPlaintext:
    """
    Converts a TEI-XML file generated by tei_builder.py back to the
    lightly-marked plaintext format.
    """
    def __init__(self, condensed_verse_format=False, line_by_line=False):
        self.lines = [""]
        self.at_line_start = True
        self.condensed_verse_format = condensed_verse_format
        self.line_by_line = line_by_line
        self.current_lg_base_n = None
        self.pending_indent = False
        self.prev_el = None

    def convert(self, xml_path: Path) -> str:
        """
        Main conversion method.

        :param xml_path: Path to the input XML file.
        :return: A string containing the reconstructed plaintext.
        """
        if not xml_path.exists():
            raise FileNotFoundError(f"Input file not found: {xml_path}")
        try:
            self.tree = etree.parse(str(xml_path))
        except etree.XMLSyntaxError as e:
            raise ValueError(f"Invalid XML in {xml_path}: {e}")

        root = self.tree.getroot()

        # Find the <body> element to start processing.
        # It should be inside <text>, but we search robustly.
        body = root.find('{*}text/{*}body')
        if body is None:
            # Fallback for older structures or variations, find the first body anywhere.
            body = root.find('.//{*}body')

        if body is None:
            return ""

        self._process_element(body)

        while self.lines and not self.lines[0]:
            self.lines.pop(0)

        return "\n".join(re.sub(r"\t\s+", "\t", l.rstrip()) for l in self.lines)

    def _append(self, text: str):
        self.lines[-1] += text
        if text.strip():
            self.at_line_start = False

    def _start_new_line(self):
        if self.lines[-1] or not self.at_line_start:
            self.lines.append("")
            self.at_line_start = True

    def _process_text(self, text: str):
        if self.at_line_start:
            text = text.lstrip()

        if not text:
            return

        # Heuristic: if text contains a newline, it's formatting whitespace.
        # Collapse it. Otherwise, preserve it.
        if '\n' in text:
            processed_text = ' '.join(text.split())
            if not processed_text:
                return
        else:
            processed_text = text

        self._append(processed_text)

    def _process_element(self, el: etree._Element):
        tag = etree.QName(el.tag).localname

        # --- PRE-CHILDREN PROCESSING ---
        if tag == 'div':
            self._start_new_line()
            self._append(f"{{{el.get('n')}}}")
            self._start_new_line()
        elif tag == 'p':
            self._start_new_line()
            self._append(f"[{el.get('n')}]")
            if not self.condensed_verse_format:
                self._start_new_line()
        elif tag == 'lg':
            parent_tag = etree.QName(el.getparent().tag).localname
            if parent_tag in ('div', 'body') or el.get('type') == 'group':
                self._start_new_line()
                if not self.condensed_verse_format:
                    self._append(f"[{el.get('n')}]")
                self._start_new_line()
        elif tag == 'l':
            if self.condensed_verse_format:
                full_label = (self.current_lg_base_n or '') + (el.get('n') or '')
                self._append(f"[{full_label}]\t")
            else:
                self._append("\t")
        elif tag == 'pb':
            if not self.condensed_verse_format or el.tail is None:
                self._start_new_line()
            if el.get('break') == 'no' and len(self.lines) > 1:
                self.lines[-2] = self.lines[-2].rstrip() + '-'
            if self.condensed_verse_format and el.tail is not None:
                self._append(f" <{el.get('n')}> ")
            else:
                self._append(f"<{el.get('n')}>")
                self._start_new_line()

        elif tag == 'lb':
            if self.line_by_line:
                if el.get('break') == 'no':
                    self.lines[-1] = self.lines[-1].rstrip() + '-'
                self._start_new_line()
            else:
                self._append(" ")
        elif tag == 'milestone':
            self._start_new_line()
            self._append(el.get('n'))
            self._start_new_line()
        elif tag == 'note':
            self._append("(")
        elif tag == 'caesura':
            self.pending_indent = True
        elif tag == 'choice':
            pass  # container
        elif tag == 'sic':
            self._append("≤")
        elif tag == 'corr':
            self._append("«")
        elif tag == 'del':
            self._append("≤")
        elif tag == 'supplied':
            self._append("«")
        elif tag == 'unclear':
            self._append("¿")

        # --- RECURSION ---
        old_lg_base = self.current_lg_base_n
        if tag == 'lg':
            self.current_lg_base_n = el.get('n')

        if el.text:
            self._process_text(el.text)

        self.prev_el = el

        for child in el:
            self._process_element(child)

            if child.tail:
                if self.pending_indent:
                    self._append("\t")
                    self.pending_indent = False
                self._process_text(child.tail)

        if tag == 'lg':
            self.current_lg_base_n = old_lg_base

        # --- POST-CHILDREN PROCESSING ---
        if tag == 'p':
            self._start_new_line()
        elif tag == 'l':
            next_el = el.getnext()
            if next_el is not None and etree.QName(next_el.tag).localname == 'back':
                pass
            else:
                self._start_new_line()
        elif tag == 'back':
            self._start_new_line()
        elif tag == 'head':
            has_lb_child = any(child.tag.endswith('lb') for child in el)
            if has_lb_child:
                self.lines.pop()
                self.lines[-1] += CHAR_FOR_PENDING_HEAD
                self._start_new_line()
            self._append('\t')
        elif tag == 'note':
            self._append(")")
        elif tag == 'sic':
            self._append("≥")
        elif tag == 'corr':
            self._append("»")
        elif tag == 'del':
            self._append("≥")
        elif tag == 'supplied':
            self._append("»")
        elif tag == 'unclear':
            self._append("¿")

    def postprocess(self, plaintext, condensed_verse_format, extra_space_after_location):
        """
        Adds more vertical spacing between elements.
        """
        plaintext = plaintext.replace('{', '\n{')

        if not condensed_verse_format:
            plaintext = plaintext.replace('}', '}\n')
            plaintext = re.sub(r'(<[^>]+>)\n+([<\[])', '\n\\1\n\n\\2', plaintext)
            plaintext = plaintext.replace(r'[', '\n[')

        if extra_space_after_location:
            plaintext = plaintext.replace(']', ']\n')

        plaintext = re.sub(r'\n{3,}', '\n\n', plaintext)
        plaintext = re.sub(r'\A\n{1,}', '', plaintext)
        plaintext = re.sub(r'\n{1,}\Z', '\n', plaintext)

        return plaintext

def configure_cli(parser: argparse.ArgumentParser):
    parser.description = "Convert TEI-XML back into lightly-marked plaintext."
    parser.add_argument("src", type=Path, help="Source TEI-XML file")
    parser.add_argument("out", type=Path, help="Destination plaintext file")
    parser.add_argument("--condensed-verse-format", action="store_true", help="Enable condensed verse format parsing logic.")
    parser.add_argument("--line-by-line", action="store_true", help="Enable line-by-line newline logic.")
    parser.add_argument("--extra-space-after-location", action="store_true", help="Add extra blank line after location markers.")

def cli():
    parser = argparse.ArgumentParser()
    configure_cli(parser)
    args = parser.parse_args()

    try:
        converter = XMLToPlaintext(condensed_verse_format=args.condensed_verse_format, line_by_line=args.line_by_line)
        plaintext = converter.convert(args.src)
        plaintext = converter.postprocess(plaintext, args.condensed_verse_format, args.extra_space_after_location)
        args.out.write_text(plaintext, encoding='utf-8')
        print(f"Wrote {args.out}")
    except (FileNotFoundError, ValueError) as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    cli()
