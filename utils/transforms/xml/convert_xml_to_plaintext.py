import argparse
from lxml import etree
from pathlib import Path
import re


class XMLToPlaintext:
    """
    Converts a TEI-XML file generated by tei_builder.py back to the
    original lightly-marked plaintext format.
    """
    def __init__(self, verse_only=False, line_by_line=False):
        self.lines = [""]
        self.at_line_start = True
        self.verse_only = verse_only
        self.line_by_line = line_by_line
        self.current_lg_base_n = None

    def convert(self, xml_path: Path) -> str:
        """
        Main conversion method.

        :param xml_path: Path to the input XML file.
        :return: A string containing the reconstructed plaintext.
        """
        if not xml_path.exists():
            raise FileNotFoundError(f"Input file not found: {xml_path}")
        try:
            self.tree = etree.parse(str(xml_path))
        except etree.XMLSyntaxError as e:
            raise ValueError(f"Invalid XML in {xml_path}: {e}")

        root = self.tree.getroot()
        body = root.find('{*}body')
        if body is None:
            return ""

        self._process_element(body)

        while self.lines and not self.lines[-1]:
            self.lines.pop()

        return "\n".join(re.sub(r"\t\s+", "\t", l.rstrip()) for l in self.lines)

    def _append(self, text: str):
        self.lines[-1] += text
        if text.strip():
            self.at_line_start = False

    def _start_new_line(self, blank_before=False):
        if blank_before:
            self.lines.append("")
            self.at_line_start = True

        if self.lines[-1] or not self.at_line_start:
            self.lines.append("")
            self.at_line_start = True

    def _process_text(self, text: str):
        if not text:
            return

        processed_text = ' '.join(text.split())
        if not processed_text:
            return

        if not self.at_line_start and not self.lines[-1].endswith(("\t", " ")):
            self._append(" ")

        self._append(processed_text)

    def _process_element(self, el: etree._Element):
        tag = etree.QName(el.tag).localname

        # --- PRE-CHILDREN PROCESSING ---
        if tag == 'div':
            self._start_new_line(blank_before=True)
            self._append(f"{{{el.get('n')}}}")
            self._start_new_line()
        elif tag == 'p':
            self._start_new_line(blank_before=True)
            self._append(f"[{el.get('n')}]")
        elif tag == 'lg':
            parent_tag = etree.QName(el.getparent().tag).localname
            if parent_tag in ('div', 'body') or el.get('type') == 'group':
                self._start_new_line(blank_before=True)
                self._append(f"[{el.get('n')}]")
                self._start_new_line()
        elif tag == 'l':
            if self.verse_only:
                full_label = (self.current_lg_base_n or '') + (el.get('n') or '')
                self._append(f"[{full_label}]\t")
            else:
                self._append("\t")
        elif tag == 'pb':
            self._start_new_line(blank_before=True)
            if el.get('break') == 'no' and len(self.lines) > 1:
                self.lines[-2] = self.lines[-2].rstrip() + '-'
            self._append(f"<{el.get('n')}>")
            self._start_new_line()
        elif tag == 'milestone':
            self._start_new_line(blank_before=True)
            self._append(el.get('n'))
            self._start_new_line()
        elif tag == 'lb':
            if self.line_by_line:
                if el.get('break') == 'no':
                    self.lines[-1] = self.lines[-1].rstrip() + '-'
                self._start_new_line()
            else:
                self._append(" ")
        elif tag == 'note':
            self._append("(")
        elif tag == 'caesura':
            self._append("\t")

        # --- RECURSION ---
        old_lg_base = self.current_lg_base_n
        if tag == 'lg':
            self.current_lg_base_n = el.get('n')

        if el.text:
            self._process_text(el.text)
        for child in el:
            self._process_element(child)
            if child.tail:
                self._process_text(child.tail)

        if tag == 'lg':
            self.current_lg_base_n = old_lg_base

        # --- POST-CHILDREN PROCESSING ---
        if tag == 'p' or tag == 'l':
            self._start_new_line()
        elif tag == 'note':
            self._append(")")

def configure_cli(parser: argparse.ArgumentParser):
    parser.description = "Convert TEI-XML back into lightly-marked plaintext."
    parser.add_argument("src", type=Path, help="Source TEI-XML file")
    parser.add_argument("out", type=Path, help="Destination plaintext file")
    parser.add_argument("--verse-only", action="store_true", help="Enable verse-only parsing logic.")
    parser.add_argument("--line-by-line", action="store_true", help="Enable line-by-line newline logic.")

def cli():
    parser = argparse.ArgumentParser()
    configure_cli(parser)
    args = parser.parse_args()

    try:
        converter = XMLToPlaintext(verse_only=args.verse_only, line_by_line=args.line_by_line)
        plaintext = converter.convert(args.src)
        args.out.write_text(plaintext, encoding='utf-8')
        print(f"Successfully converted {args.src} to {args.out}")
    except (FileNotFoundError, ValueError) as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    cli()