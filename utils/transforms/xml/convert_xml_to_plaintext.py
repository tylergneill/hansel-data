import argparse
from lxml import etree
from pathlib import Path
import re


class XMLToPlaintext:
    """
    Converts a TEI-XML file generated by tei_builder.py back to the
    original lightly-marked plaintext format.
    """
    def __init__(self, verse_only=False, line_by_line=False):
        self.lines = [""]
        self.at_line_start = True
        self.verse_only = verse_only
        self.line_by_line = line_by_line
        self.current_lg_base_n = None
        self.pending_indent = False
        self.prev_el = None

    def convert(self, xml_path: Path) -> str:
        """
        Main conversion method.

        :param xml_path: Path to the input XML file.
        :return: A string containing the reconstructed plaintext.
        """
        if not xml_path.exists():
            raise FileNotFoundError(f"Input file not found: {xml_path}")
        try:
            self.tree = etree.parse(str(xml_path))
        except etree.XMLSyntaxError as e:
            raise ValueError(f"Invalid XML in {xml_path}: {e}")

        root = self.tree.getroot()
        body = root.find('{*}body')
        if body is None:
            return ""

        self._process_element(body)

        while self.lines and not self.lines[0]:
            self.lines.pop(0)

        return "\n".join(re.sub(r"\t\s+", "\t", l.rstrip()) for l in self.lines)

    def _append(self, text: str):
        self.lines[-1] += text
        if text.strip():
            self.at_line_start = False

    def _start_new_line(self, blank_before=False):
        if blank_before:
            self.lines.append("")
            self.at_line_start = True

        if self.lines[-1] or not self.at_line_start:
            self.lines.append("")
            self.at_line_start = True

    def _process_text(self, text: str):
        if not text:
            return

        processed_text = ' '.join(text.split())
        if not processed_text:
            return

        if not self.at_line_start and not self.lines[-1].endswith(("\t", " ")):
            self._append(" ")

        self._append(processed_text)

    def _space_out_prev_pb(self):
        if self.prev_el.tag == 'pb' and not self.verse_only:
            ultimate_el = self.lines.pop()
            pentultimate_el = self.lines.pop()
            self.lines.extend(['', pentultimate_el, ultimate_el])

    def _process_element(self, el: etree._Element):
        tag = etree.QName(el.tag).localname


        # --- PRE-CHILDREN PROCESSING ---
        if tag == 'div':
            self._space_out_prev_pb()
            self._start_new_line(blank_before=True)
            self._append(f"{{{el.get('n')}}}")
            self._start_new_line()
        elif tag == 'p':
            self._space_out_prev_pb()
            self._start_new_line(blank_before=not self.verse_only)
            self._append(f"[{el.get('n')}]")
            if not self.verse_only:
                self._start_new_line()
        elif tag == 'lg':
            parent_tag = etree.QName(el.getparent().tag).localname
            if parent_tag in ('div', 'body') or el.get('type') == 'group':
                self._space_out_prev_pb()
                self._start_new_line(blank_before=not self.verse_only)
                if not self.verse_only:
                    self._append(f"[{el.get('n')}]")
                self._start_new_line()
        elif tag == 'l':
            if self.verse_only:
                full_label = (self.current_lg_base_n or '') + (el.get('n') or '')
                self._append(f"[{full_label}]\t")
            else:
                self._append("\t")
        elif tag == 'pb':
            if not self.verse_only or el.tail is None:
                self._start_new_line(blank_before=not self.verse_only)
            if el.get('break') == 'no' and len(self.lines) > 1:
                self.lines[-2] = self.lines[-2].rstrip() + '-'
            if self.verse_only and el.tail is not None:
                self._append(f" <{el.get('n')}> ")
            else:
                self._append(f"<{el.get('n')}>")
                self._start_new_line()

        elif tag == 'lb':
            if self.line_by_line:
                if el.get('break') == 'no':
                    self.lines[-1] = self.lines[-1].rstrip() + '-'
                self._start_new_line()
            else:
                self._append(" ")
        elif tag == 'milestone':
            self._start_new_line(blank_before=not self.verse_only)
            self._append(el.get('n'))
            self._start_new_line()
        elif tag == 'note':
            self._append("(")
        elif tag == 'caesura':
            self.pending_indent = True

        # --- RECURSION ---
        old_lg_base = self.current_lg_base_n
        if tag == 'lg':
            self.current_lg_base_n = el.get('n')

        if el.text:
            if el.tag  == 'back':
                self.lines.pop()
                self.lines[-1] += " "
            self._process_text(el.text)

        self.prev_el = el

        for child in el:
            self._process_element(child)

            if child.tail:
                if self.pending_indent:
                    self._append("\t")
                    self.pending_indent = False
                self._process_text(child.tail)

        if tag == 'lg':
            self.current_lg_base_n = old_lg_base

        # --- POST-CHILDREN PROCESSING ---
        if tag == 'p':
            self._start_new_line()
        elif tag == 'l':
            next_el = el.getnext()
            if next_el is not None and etree.QName(next_el.tag).localname == 'back':
                pass
            else:
                self._start_new_line()
        elif tag == 'back':
            self._start_new_line()
        elif tag == 'head':
            has_lb_child = any(child.tag.endswith('lb') for child in el)
            if has_lb_child:
                self.lines.pop()
                self.lines[-1] += "-"
                self._start_new_line()
            self._append('\t')
        elif tag == 'note':
            self._append(")")

def configure_cli(parser: argparse.ArgumentParser):
    parser.description = "Convert TEI-XML back into lightly-marked plaintext."
    parser.add_argument("src", type=Path, help="Source TEI-XML file")
    parser.add_argument("out", type=Path, help="Destination plaintext file")
    parser.add_argument("--verse-only", action="store_true", help="Enable verse-only parsing logic.")
    parser.add_argument("--line-by-line", action="store_true", help="Enable line-by-line newline logic.")
    parser.add_argument("--extra-space-after-location", action="store_true", help="Add extra blank line after location markers.")

def cli():
    parser = argparse.ArgumentParser()
    configure_cli(parser)
    args = parser.parse_args()

    try:
        converter = XMLToPlaintext(verse_only=args.verse_only, line_by_line=args.line_by_line)
        plaintext = converter.convert(args.src)
        if args.extra_space_after_location:
            plaintext = plaintext.replace(']\n', ']\n\n')
        args.out.write_text(plaintext, encoding='utf-8')
        print(f"Wrote {args.out}")
    except (FileNotFoundError, ValueError) as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    cli()